import os
import re
import sys
import json
import time
import asyncio
import requests
import random
import yt_dlp
import tgcrypto
from logs import logging
from bs4 import BeautifulSoup
import saini as helper
from utils import progress_bar
from vars import API_ID, API_HASH, BOT_TOKEN, CREDIT, TOTAL_USERS, OWNER
from aiohttp import ClientSession
from subprocess import getstatusoutput
from pyromod import listen
from pyrogram import Client, filters
from pyrogram.types import Message, CallbackQuery
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from pyrogram.errors import FloodWait, PeerIdInvalid, UserIsBlocked, InputUserDeactivated
import aiohttp
import aiofiles
import zipfile
import shutil
import ffmpeg

# Initialize bot
bot = Client(
    "bot",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN
)

processing_request = False
cancel_requested = False
cookies_file_path = os.getenv("cookies_file_path", "youtube_cookies.txt")

# Keyboard for start/help
BUTTONSCONTACT = InlineKeyboardMarkup([[InlineKeyboardButton(text="üìû Contact", url="https://t.me/saini_contact_bot")]])
keyboard = InlineKeyboardMarkup(
    [
        [
            InlineKeyboardButton(text="üìû Contact", url="https://t.me/saini_contact_bot"),
            InlineKeyboardButton(text="üõ†Ô∏è Repo", url="https://github.com/nikhilsainiop/saini-txt-direct")
        ],
        [
            InlineKeyboardButton("‚ú® Features", callback_data="features"),
            InlineKeyboardButton("üí• Commands", callback_data="commands")
        ],
        [
            InlineKeyboardButton("üöÄ Plans", callback_data="plans")
        ]
    ]
)

# Random photos
image_urls = [
    "https://tinypic.host/images/2025/02/07/IMG_20250207_224444_975.jpg",
    "https://tinypic.host/images/2025/02/07/DeWatermark.ai_1738952933236-1.png",
    "https://tinypic.host/images/2025/03/18/YouTube-Logo.wine.png",
    "https://tinypic.host/images/2025/03/28/IMG_20250328_133126.jpg",
]

# =============== START =================
@bot.on_message(filters.command("start"))
async def start(bot, m: Message):
    user_id = m.chat.id
    if user_id not in TOTAL_USERS:
        TOTAL_USERS.append(user_id)

    photo = random.choice(image_urls)
    caption = (
        "‚û¶K Haal h üòÅ‚ù§Ô∏è\n\n"
        "‚Ä¢ Œπ ·•≤m txt to vŒπd·•±o œÖœÅ·•£o·•≤d·•±r bot.\n\n"
        "‚Ä¢ for œÖpload s·•±·•íd /mars\n\n"
        "‚Ä¢ for gœÖŒπd·•± s·•±·•íd /help"
    )
    await bot.send_photo(
        chat_id=m.chat.id,
        photo=photo,
        caption=caption,
        reply_markup=keyboard
    )

# =============== STOP =================
@bot.on_message(filters.command("stop"))
async def cancel_handler(client: Client, m: Message):
    global processing_request, cancel_requested
    if processing_request:
        cancel_requested = True
        await m.reply_text("**üö¶ Process cancel request received. Stopping after current process...**")
    else:
        await m.reply_text("**‚ö° No active process to cancel.**")

# =============== MARS (replaces DRM) =================
@bot.on_message(filters.command(["mars"]))
async def txt_handler(bot: Client, m: Message):  
    global processing_request, cancel_requested
    processing_request = True
    cancel_requested = False

    editable = await m.reply_text(
        "**__Hii, I am Mars Downloader Bot__\n"
        "<blockquote><i>Send Me Your text file which includes Name with url...\nE.g: Name: Link</i></blockquote>\n"
        "<blockquote><i>All input auto taken in 20 sec\nPlease send all input in 20 sec...</i></blockquote>**"
    )

    input: Message = await bot.listen(editable.chat.id)
    x = await input.download()
    await input.delete(True)

    file_name, ext = os.path.splitext(os.path.basename(x))
    path = f"./downloads/{m.chat.id}"

    pdf_count = 0
    img_count = 0
    v2_count = 0
    mpd_count = 0
    m3u8_count = 0
    yt_count = 0
    drm_count = 0
    zip_count = 0
    other_count = 0
    
    try:    
        with open(x, "r") as f:
            content = f.read()
        content = content.split("\n")
        
        links = []
        for i in content:
            if "://" in i:
                url = i.split("://", 1)[1]
                links.append(i.split("://", 1))
                if ".pdf" in url:
                    pdf_count += 1
                elif url.endswith((".png", ".jpeg", ".jpg")):
                    img_count += 1
                elif "v2" in url:
                    v2_count += 1
                elif "mpd" in url:
                    mpd_count += 1
                elif "m3u8" in url:
                    m3u8_count += 1
                elif "drm" in url:
                    drm_count += 1
                elif "youtu" in url:
                    yt_count += 1
                elif "zip" in url:
                    zip_count += 1
                else:
                    other_count += 1
        os.remove(x)
    except:
        await m.reply_text("<b>üîπInvalid file input.</b>")
        os.remove(x)
        return
    
    await editable.edit(f"**Total üîó links found are {len(links)}\n<blockquote>‚Ä¢PDF : {pdf_count}      ‚Ä¢V2 : {v2_count}\n‚Ä¢Img : {img_count}      ‚Ä¢YT : {yt_count}\n‚Ä¢zip : {zip_count}       ‚Ä¢m3u8 : {m3u8_count}\n‚Ä¢drm : {drm_count}      ‚Ä¢Other : {other_count}\n‚Ä¢mpd : {mpd_count}</blockquote>\nSend From where you want to download**")
    try:
        input0: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text = input0.text
        await input0.delete(True)
    except asyncio.TimeoutError:
        raw_text = '1'
    
    if int(raw_text) > len(links) :
        await editable.edit(f"**üîπEnter number in range of Index (01-{len(links)})**")
        processing_request = False  # Reset the processing flag
        await m.reply_text("**üîπExiting Task......  **")
        return
        
    await editable.edit(f"**Enter Batch Name or send /d**")
    try:
        input1: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text0 = input1.text
        await input1.delete(True)
    except asyncio.TimeoutError:
        raw_text0 = '/d'
    
    if raw_text0 == '/d':
        b_name = file_name.replace('_', ' ')
    else:
        b_name = raw_text0
    
    await editable.edit("__**Enter resolution or Video Quality (`144`, `240`, `360`, `480`, `720`, `1080`)**__")
    try:
        input2: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text2 = input2.text
        await input2.delete(True)
    except asyncio.TimeoutError:
        raw_text2 = '480'
    quality = f"{raw_text2}p"
    try:
        if raw_text2 == "144":
            res = "256x144"
        elif raw_text2 == "240":
            res = "426x240"
        elif raw_text2 == "360":
            res = "640x360"
        elif raw_text2 == "480":
            res = "854x480"
        elif raw_text2 == "720":
            res = "1280x720"
        elif raw_text2 == "1080":
            res = "1920x1080" 
        else: 
            res = "UN"
    except Exception:
            res = "UN"

    await editable.edit(f"**Enter the Credit Name or send /d\n\n<blockquote><b>Format:</b>\nüîπSend __Admin__ only for caption\nüîπSend __Admin,filename__ for caption and file...Separate them with a comma (,)</blockquote>**")
    try:
        input3: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text3 = input3.text
        await input3.delete(True)
    except asyncio.TimeoutError:
        raw_text3 = '/d'
        
    if raw_text3 == '/d':
        CR = f"{CREDIT}"
    elif "," in raw_text3:
        CR, PRENAME = raw_text3.split(",")
    else:
        CR = raw_text3

    await editable.edit("**Enter ùêèùêñ/ùêÇùêñ/ùêÇùêè Working Token For ùêåùêèùêÉ ùêîùêëùêã or send /d**\n\n<blockquote><b>Note: If you are downloading Classplus Video, Make sure you joined @bots_updatee this channel.</b></blockquote>")
    try:
        input4: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text4 = input4.text
        await input4.delete(True)
    except asyncio.TimeoutError:
        raw_text4 = '/d'

    if raw_text4 == '/d':
        cwtoken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpYXQiOjE3MjQyMzg3OTEsImNvbiI6eyJpc0FkbWluIjpmYWxzZSwiYXVzZXIiOiJVMFZ6TkdGU2NuQlZjR3h5TkZwV09FYzBURGxOZHowOSIsImlkIjoiZEUxbmNuZFBNblJqVEROVmFWTlFWbXhRTkhoS2R6MDkiLCJmaXJzdF9uYW1lIjoiYVcxV05ITjVSemR6Vm10ak1WUlBSRkF5ZVNzM1VUMDkiLCJlbWFpbCI6Ik5Ga3hNVWhxUXpRNFJ6VlhiR0ppWTJoUk0wMVdNR0pVTlU5clJXSkRWbXRMTTBSU2FHRnhURTFTUlQwPSIsInBob25lIjoiVUhVMFZrOWFTbmQ1ZVcwd1pqUTViRzVSYVc5aGR6MDkiLCJhdmF0YXIiOiJLM1ZzY1M4elMwcDBRbmxrYms4M1JEbHZla05pVVQwOSIsInJlZmVycmFsX2NvZGUiOiJOalZFYzBkM1IyNTBSM3B3VUZWbVRtbHFRVXAwVVQwOSIsImRldmljZV90eXBlIjoiYW5kcm9pZCIsImRldmljZV92ZXJzaW9uIjoiUShBbmRyb2lkIDEwLjApIiwiZGV2aWNlX21vZGVsIjoiU2Ftc3VuZyBTTS1TOTE4QiIsInJlbW90ZV9hZGRyIjoiNTQuMjI2LjI1NS4xNjMsIDU0LjIyNi4yNTUuMTYzIn19.snDdd-PbaoC42OUhn5SJaEGxq0VzfdzO49WTmYgTx8ra_Lz66GySZykpd2SxIZCnrKR6-R10F5sUSrKATv1CDk9ruj_ltCjEkcRq8mAqAytDcEBp72-W0Z7DtGi8LdnY7Vd9Kpaf499P-y3-godolS_7ixClcYOnWxe2nSVD5C9c5HkyisrHTvf6NFAuQC_FD3TzByldbPVKK0ag1UnHRavX8MtttjshnRhv5gJs5DQWj4Ir_dkMcJ4JaVZO3z8j0OxVLjnmuaRBujT-1pavsr1CCzjTbAcBvdjUfvzEhObWfA1-Vl5Y4bUgRHhl1U-0hne4-5fF0aouyu71Y6W0eg'
        cptoken = "cptoken"
        pwtoken = "pwtoken"
    else:
        cwtoken = raw_text4
        cptoken = raw_text4
        pwtoken = raw_text4

    await editable.edit("**If you want to topic wise uploader : send `yes` or send /d**\n\n<blockquote><b>Topic fetch from (bracket) in title</b></blockquote>")
    try:
        input5: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text5 = input5.text
        await input5.delete(True)
    except asyncio.TimeoutError:
        raw_text5 = '/d'
        
    await editable.edit(f"**Send the Video Thumb URL or send /d**")
    try:
        input6: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text6 = input6.text
        await input6.delete(True)
    except asyncio.TimeoutError:
        raw_text6 = '/d'

    if raw_text6.startswith("http://") or raw_text6.startswith("https://"):
        # If a URL is provided, download thumbnail from the URL
        getstatusoutput(f"wget '{raw_text6}' -O 'thumb.jpg'")
        thumb = "thumb.jpg"
    else:
        thumb = raw_text6

    await editable.edit("__**‚ö†Ô∏èProvide the Channel ID or send /d__\n\n<blockquote><i>üîπ Make me an admin to upload.\nüî∏Send /id in your channel to get the Channel ID.\n\nExample: Channel ID = -100XXXXXXXXXXX</i></blockquote>\n**")
    try:
        input7: Message = await bot.listen(editable.chat.id, timeout=20)
        raw_text7 = input7.text
        await input7.delete(True)
    except asyncio.TimeoutError:
        raw_text7 = '/d'

    if "/d" in raw_text7:
        channel_id = m.chat.id
    else:
        channel_id = raw_text7    
    await editable.delete()

    try:
        if raw_text == "1":
            batch_message = await bot.send_message(chat_id=channel_id, text=f"<blockquote><b>üéØTarget Batch : {b_name}</b></blockquote>")
            if "/d" not in raw_text7:
                await bot.send_message(chat_id=m.chat.id, text=f"<blockquote><b><i>üéØTarget Batch : {b_name}</i></b></blockquote>\n\nüîÑ Your Task is under processing, please check your Set Channelüì±. Once your task is complete, I will inform you üì©")
                await bot.pin_chat_message(channel_id, batch_message.id)
                message_id = batch_message.id
                pinning_message_id = message_id + 1
                await bot.delete_messages(channel_id, pinning_message_id)
        else:
             if "/d" not in raw_text7:
                await bot.send_message(chat_id=m.chat.id, text=f"<blockquote><b><i>üéØTarget Batch : {b_name}</i></b></blockquote>\n\nüîÑ Your Task is under processing, please check your Set Channelüì±. Once your task is complete, I will inform you üì©")
    except Exception as e:
        await m.reply_text(f"**Fail Reason ¬ª**\n<blockquote><i>{e}</i></blockquote>\n\n‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}üåü`")

        
    failed_count = 0
    count =int(raw_text)    
    arg = int(raw_text)
    try:
        for i in range(arg-1, len(links)):
            if cancel_requested:
                await m.reply_text("üö¶**STOPPED**üö¶")
                processing_request = False
                cancel_requested = False
                return
  
            Vxy = links[i][1].replace("file/d/","uc?export=download&id=").replace("www.youtube-nocookie.com/embed", "youtu.be").replace("?modestbranding=1", "").replace("/view?usp=sharing","")
            url = "https://" + Vxy
            link0 = "https://" + Vxy

            name1 = links[i][0].replace("(", "[").replace(")", "]").replace("_", "").replace("\t", "").replace(":", "").replace("/", "").replace("+", "").replace("#", "").replace("|", "").replace("@", "").replace("*", "").replace(".", "").replace("https", "").replace("http", "").strip()
            if "," in raw_text3:
                 name = f'{PRENAME} {name1[:60]}'
            else:
                 name = f'{name1[:60]}'
            
            if "visionias" in url:
                async with ClientSession() as session:
                    async with session.get(url, headers={'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'Accept-Language': 'en-US,en;q=0.9', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'Pragma': 'no-cache', 'Referer': 'http://www.visionias.in/', 'Sec-Fetch-Dest': 'iframe', 'Sec-Fetch-Mode': 'navigate', 'Sec-Fetch-Site': 'cross-site', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Linux; Android 12; RMX2121) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Mobile Safari/537.36', 'sec-ch-ua': '"Chromium";v="107", "Not=A?Brand";v="24"', 'sec-ch-ua-mobile': '?1', 'sec-ch-ua-platform': '"Android"',}) as resp:
                        text = await resp.text()
                        url = re.search(r"(https://.*?playlist.m3u8.*?)\"", text).group(1)

            if "acecwply" in url:
                cmd = f'yt-dlp -o "{name}.%(ext)s" -f "bestvideo[height<={raw_text2}]+bestaudio" --hls-prefer-ffmpeg --no-keep-video --remux-video mkv --no-warning "{url}"'

            elif "https://cpvod.testbook.com/" in url or "classplusapp.com/drm/" in url:
                url = url.replace("https://cpvod.testbook.com/","https://media-cdn.classplusapp.com/drm/")
                url = f"https://cpapi-ytas.onrender.com/extract_keys?url={url}@bots_updatee&user_id={7452654429}"
                #url = f"https://scammer-keys.vercel.app/api?url={url}&token={cptoken}&auth=@scammer_botxz1"
                mpd, keys = helper.get_mps_and_keys(url)
                url = mpd
                keys_string = " ".join([f"--key {key}" for key in keys])

            elif "classplusapp" in url:
                signed_api = f"https://cpapi-ytas.onrender.com/extract_keys?url={url}@bots_updatee&user_id={7452654429}"
                response = requests.get(signed_api, timeout=20)
                #url = response.text.strip()
                url = response.json()['url']  
                    
            elif "tencdn.classplusapp" in url:
                headers = {'host': 'api.classplusapp.com', 'x-access-token': f'{cptoken}', 'accept-language': 'EN', 'api-version': '18', 'app-version': '1.4.73.2', 'build-number': '35', 'connection': 'Keep-Alive', 'content-type': 'application/json', 'device-details': 'Xiaomi_Redmi 7_SDK-32', 'device-id': 'c28d3cb16bbdac01', 'region': 'IN', 'user-agent': 'Mobile-Android', 'webengage-luid': '00000187-6fe4-5d41-a530-26186858be4c', 'accept-encoding': 'gzip'}
                params = {"url": f"{url}"}
                response = requests.get('https://api.classplusapp.com/cams/uploader/video/jw-signed-url', headers=headers, params=params)
                url = response.json()['url']  
           
            elif 'videos.classplusapp' in url:
                url = requests.get(f'https://api.classplusapp.com/cams/uploader/video/jw-signed-url?url={url}', headers={'x-access-token': f'{cptoken}'}).json()['url']
            
            elif 'media-cdn.classplusapp.com' in url or 'media-cdn-alisg.classplusapp.com' in url or 'media-cdn-a.classplusapp.com' in url: 
                headers = {'host': 'api.classplusapp.com', 'x-access-token': f'{cptoken}', 'accept-language': 'EN', 'api-version': '18', 'app-version': '1.4.73.2', 'build-number': '35', 'connection': 'Keep-Alive', 'content-type': 'application/json', 'device-details': 'Xiaomi_Redmi 7_SDK-32', 'device-id': 'c28d3cb16bbdac01', 'region': 'IN', 'user-agent': 'Mobile-Android', 'webengage-luid': '00000187-6fe4-5d41-a530-26186858be4c', 'accept-encoding': 'gzip'}
                params = {"url": f"{url}"}
                response = requests.get('https://api.classplusapp.com/cams/uploader/video/jw-signed-url', headers=headers, params=params)
                url   = response.json()['url']

            if "edge.api.brightcove.com" in url:
                bcov = f'bcov_auth={cwtoken}'
                url = url.split("bcov_auth")[0]+bcov
                
            elif "childId" in url and "parentId" in url:
                url = f"https://anonymouspwplayerr-f996115ea61a.herokuapp.com/pw?url={url}&token={pw_token}"
                           
            elif "d1d34p8vz63oiq" in url or "sec1.pw.live" in url:
                url = f"https://anonymouspwplayer-b99f57957198.herokuapp.com/pw?url={url}?token={pwtoken}"

            if ".pdf*" in url:
                url = f"https://dragoapi.vercel.app/pdf/{url}"
            
            elif 'encrypted.m' in url:
                appxkey = url.split('*')[1]
                url = url.split('*')[0]

            if "youtu" in url:
                ytf = f"bv*[height<={raw_text2}][ext=mp4]+ba[ext=m4a]/b[height<=?{raw_text2}]"
            elif "embed" in url:
                ytf = f"bestvideo[height<={raw_text2}]+bestaudio/best[height<={raw_text2}]"
            else:
                ytf = f"b[height<={raw_text2}]/bv[height<={raw_text2}]+ba/b/bv+ba"
           
            if "jw-prod" in url:
                cmd = f'yt-dlp -o "{name}.mp4" "{url}"'
            elif "webvideos.classplusapp." in url:
               cmd = f'yt-dlp --add-header "referer:https://web.classplusapp.com/" --add-header "x-cdn-tag:empty" -f "{ytf}" "{url}" -o "{name}.mp4"'
            elif "youtube.com" in url or "youtu.be" in url:
                cmd = f'yt-dlp --cookies youtube_cookies.txt -f "{ytf}" "{url}" -o "{name}".mp4'
            else:
                cmd = f'yt-dlp -f "{ytf}" "{url}" -o "{name}.mp4"'

            try:
                if raw_text5 == "yes":
                    raw_title = links[i][0]
                    t_match = re.search(r"[\(\[]([^\)\]]+)[\)\]]", raw_title)
                    if t_match:
                        t_name = t_match.group(1).strip()
                        v_name = re.sub(r"^[\(\[][^\)\]]+[\)\]]\s*", "", raw_title)
                        v_name = re.sub(r"[\(\[][^\)\]]+[\)\]]", "", v_name)
                        v_name = re.sub(r":.*", "", v_name).strip()
                    else:
                        t_name = "Untitled"
                        v_name = re.sub(r":.*", "", raw_title).strip()
                    
                    cc = f'‚õ¶ Vid Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    cc1 = f'‚õ¶ Pdf Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    cczip = f'‚õ¶ Zip Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    ccimg = f'‚õ¶ Img Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    cchtml = f'‚õ¶ Html Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    ccyt = f'‚õ¶ Vid Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<a href="{url}">__**Click Here to Watch Stream**__</a>\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                    ccm = f'‚õ¶ Mp3 Id : {str(count).zfill(3)}\n\n**Title :** {v_name}\n\n<blockquote><b>üìî Course : {b_name}</b></blockquote>\n<blockquote><b>‚úé·ù∞.Topic : {t_name}</b></blockquote>\n\n**Downloaded By-**{CR}\n'
                else:
                    cc = f'‚õ¶ Vid Id : {str(count).zfill(3)}\n\n**Title :** {name1} \n\n<blockquote><b>üìî Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n'
                cc1 = f'‚õ¶ Pdf Id : {str(count).zfill(3)}\n\n**Title :** {name1}\n\n<blockquote><b>üìî Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n'
                cczip = f'‚õ¶ Zip Id : {str(count).zfill(3)}\n\n**Title :** {name1}\n\n<blockquote><b>üìî Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n' 
                ccimg = f'‚õ¶ Img Id : {str(count).zfill(3)}\n\n**Title :** {name1}\n\n<blockquote><b>üìî Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n'
                ccm = f'‚õ¶ Audio Id : {str(count).zfill(3)}\n\n**Title :** {name1}\n\n<blockquote><b>üìî Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n'
                cchtml = f'‚õ¶ Html Id : {str(count).zfill(3)}\n\n**Title :** {name1}\n\n<blockquote><b>üìó Course :</b> {b_name}</blockquote>\n\n**Downloaded By-**{CR}\n'
    
                if "drive" in url:
                    try:
                        ka = await helper.download(url, name)
                        copy = await bot.send_document(chat_id=channel_id,document=ka, caption=cc1)
                        count+=1
                        os.remove(ka)
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
  
                elif ".pdf" in url:
                    if "cwmediabkt99" in url:
                        max_retries = 15  # Define the maximum number of retries
                        retry_delay = 4  # Delay between retries in seconds
                        success = False  # To track whether the download was successful
                        failure_msgs = []  # To keep track of failure messages
                        
                        for attempt in range(max_retries):
                            try:
                                await asyncio.sleep(retry_delay)
                                url = url.replace(" ", "%20")
                                scraper = cloudscraper.create_scraper()
                                response = scraper.get(url)

                                if response.status_code == 200:
                                    with open(f'{name}.pdf', 'wb') as file:
                                        file.write(response.content)
                                    await asyncio.sleep(retry_delay)  # Optional, to prevent spamming
                                    copy = await bot.send_document(chat_id=channel_id, document=f'{name}.pdf', caption=cc1)
                                    count += 1
                                    os.remove(f'{name}.pdf')
                                    success = True
                                    break  # Exit the retry loop if successful
                                else:
                                    failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {response.status_code} {response.reason}")
                                    failure_msgs.append(failure_msg)
                                    
                            except Exception as e:
                                failure_msg = await m.reply_text(f"Attempt {attempt + 1}/{max_retries} failed: {str(e)}")
                                failure_msgs.append(failure_msg)
                                await asyncio.sleep(retry_delay)
                                continue 
                        for msg in failure_msgs:
                            await msg.delete()
                            
                    else:
                        try:
                            cmd = f'yt-dlp -o "{name}.pdf" "{url}"'
                            download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                            os.system(download_cmd)
                            copy = await bot.send_document(chat_id=channel_id, document=f'{name}.pdf', caption=cc1)
                            count += 1
                            os.remove(f'{name}.pdf')
                        except FloodWait as e:
                            await m.reply_text(str(e))
                            time.sleep(e.x)
                            continue    

                elif ".ws" in url and  url.endswith(".ws"):
                    try:
                        await helper.pdf_download(f"{api_url}utkash-ws?url={url}&authorization={api_token}",f"{name}.html")
                        time.sleep(1)
                        await bot.send_document(chat_id=channel_id, document=f"{name}.html", caption=cchtml)
                        os.remove(f'{name}.html')
                        count += 1
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
                            
                elif any(ext in url for ext in [".jpg", ".jpeg", ".png"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        copy = await bot.send_photo(chat_id=channel_id, photo=f'{name}.{ext}', caption=ccimg)
                        count += 1
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    

                elif any(ext in url for ext in [".mp3", ".wav", ".m4a"]):
                    try:
                        ext = url.split('.')[-1]
                        cmd = f'yt-dlp -o "{name}.{ext}" "{url}"'
                        download_cmd = f"{cmd} -R 25 --fragment-retries 25"
                        os.system(download_cmd)
                        copy = await bot.send_document(chat_id=channel_id, document=f'{name}.{ext}', caption=ccm)
                        count += 1
                        os.remove(f'{name}.{ext}')
                    except FloodWait as e:
                        await m.reply_text(str(e))
                        time.sleep(e.x)
                        continue    
                    
                elif 'encrypted.m' in url:    
                    remaining_links = len(links) - count
                    progress = (count / len(links)) * 100
                    Show1 = f"<blockquote>üöÄùêèùê´ùê®ùê†ùê´ùêûùê¨ùê¨ ¬ª {progress:.2f}%</blockquote>\n‚îÉ\n" \
                           f"‚î£üîóùêàùêßùêùùêûùê± ¬ª {count}/{len(links)}\n‚îÉ\n" \
                           f"‚ï∞‚îÅüñáÔ∏èùêëùêûùê¶ùêöùê¢ùêß ¬ª {remaining_links}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote><b>‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ E…¥·¥Ñ Ä è·¥ò·¥õ·¥á·¥Ö S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥</b></blockquote>\n‚îÉ\n" \
                           f'‚î£üíÉùêÇùê´ùêûùêùùê¢ùê≠ ¬ª {CR}\n‚îÉ\n' \
                           f"‚ï∞‚îÅüìöùêÅùêöùê≠ùêúùê° ¬ª {b_name}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote>üìöùêìùê¢ùê≠ùê•ùêû ¬ª {name}</blockquote>\n‚îÉ\n" \
                           f"‚î£üçÅùêêùêÆùêöùê•ùê¢ùê≠ùê≤ ¬ª {quality}\n‚îÉ\n" \
                           f'‚î£‚îÅüîóùêãùê¢ùêßùê§ ¬ª <a href="{link0}">**Original Link**</a>\n‚îÉ\n' \
                           f'‚ï∞‚îÅ‚îÅüñáÔ∏èùêîùê´ùê• ¬ª <a href="{url}">**Api Link**</a>\n' \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"üõë**Send** /stop **to stop process**\n‚îÉ\n" \
                           f"‚ï∞‚îÅ‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>" 
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    prog1 = await m.reply_text(Show1, disable_web_page_preview=True)
                    res_file = await helper.download_and_decrypt_video(url, cmd, name, appxkey)  
                    filename = res_file  
                    await prog1.delete(True)
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1  
                    await asyncio.sleep(1)  
                    continue  

                elif 'drmcdni' in url or 'drm/wv' in url:
                    remaining_links = len(links) - count
                    progress = (count / len(links)) * 100
                    Show1 = f"<blockquote>üöÄùêèùê´ùê®ùê†ùê´ùêûùê¨ùê¨ ¬ª {progress:.2f}%</blockquote>\n‚îÉ\n" \
                           f"‚î£üîóùêàùêßùêùùêûùê± ¬ª {count}/{len(links)}\n‚îÉ\n" \
                           f"‚ï∞‚îÅüñáÔ∏èùêëùêûùê¶ùêöùê¢ùêß ¬ª {remaining_links}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote><b>‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥</b></blockquote>\n‚îÉ\n" \
                           f'‚î£üíÉùêÇùê´ùêûùêùùê¢ùê≠ ¬ª {CR}\n‚îÉ\n' \
                           f"‚ï∞‚îÅüìöùêÅùêöùê≠ùêúùê° ¬ª {b_name}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote>üìöùêìùê¢ùê≠ùê•ùêû ¬ª {name}</blockquote>\n‚îÉ\n" \
                           f"‚î£üçÅùêêùêÆùêöùê•ùê¢ùê≠ùê≤ ¬ª {quality}\n‚îÉ\n" \
                           f'‚î£‚îÅüîóùêãùê¢ùêßùê§ ¬ª <a href="{link0}">**Original Link**</a>\n‚îÉ\n' \
                           f'‚ï∞‚îÅ‚îÅüñáÔ∏èùêîùê´ùê• ¬ª <a href="{url}">**Api Link**</a>\n' \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"üõë**Send** /stop **to stop process**\n‚îÉ\n" \
                           f"‚ï∞‚îÅ‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>"
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    prog1 = await m.reply_text(Show1, disable_web_page_preview=True)
                    res_file = await helper.decrypt_and_merge_video(mpd, keys_string, path, name, raw_text2)
                    filename = res_file
                    await prog1.delete(True)
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1
                    await asyncio.sleep(1)
                    continue
     
                else:
                    remaining_links = len(links) - count
                    progress = (count / len(links)) * 100
                    Show1 = f"<blockquote>üöÄùêèùê´ùê®ùê†ùê´ùêûùê¨ùê¨ ¬ª {progress:.2f}%</blockquote>\n‚îÉ\n" \
                           f"‚î£üîóùêàùêßùêùùêûùê± ¬ª {count}/{len(links)}\n‚îÉ\n" \
                           f"‚ï∞‚îÅüñáÔ∏èùêëùêûùê¶ùêöùê¢ùêß ¬ª {remaining_links}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote><b>‚ö°D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ S·¥õ·¥Ä Ä·¥õ·¥á·¥Ö...‚è≥</b></blockquote>\n‚îÉ\n" \
                           f'‚î£üíÉùêÇùê´ùêûùêùùê¢ùê≠ ¬ª {CR}\n‚îÉ\n' \
                           f"‚ï∞‚îÅüìöùêÅùêöùê≠ùêúùê° ¬ª {b_name}\n" \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"<blockquote>üìöùêìùê¢ùê≠ùê•ùêû ¬ª {name}</blockquote>\n‚îÉ\n" \
                           f"‚î£üçÅùêêùêÆùêöùê•ùê¢ùê≠ùê≤ ¬ª {quality}\n‚îÉ\n" \
                           f'‚î£‚îÅüîóùêãùê¢ùêßùê§ ¬ª <a href="{link0}">**Original Link**</a>\n‚îÉ\n' \
                           f'‚ï∞‚îÅ‚îÅüñáÔ∏èùêîùê´ùê• ¬ª <a href="{url}">**Api Link**</a>\n' \
                           f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n" \
                           f"üõë**Send** /stop **to stop process**\n‚îÉ\n" \
                           f"‚ï∞‚îÅ‚ú¶ùêÅùê®ùê≠ ùêåùêöùêùùêû ùêÅùê≤ ‚ú¶ {CREDIT}"
                    Show = f"<i><b>Video Downloading</b></i>\n<blockquote><b>{str(count).zfill(3)}) {name1}</b></blockquote>"
                    prog = await bot.send_message(channel_id, Show, disable_web_page_preview=True)
                    prog1 = await m.reply_text(Show1, disable_web_page_preview=True)
                    res_file = await helper.download_video(url, cmd, name)
                    filename = res_file
                    await prog1.delete(True)
                    await prog.delete(True)
                    await helper.send_vid(bot, m, cc, filename, thumb, name, prog, channel_id)
                    count += 1
                    time.sleep(1)
                
            except Exception as e:
                await bot.send_message(channel_id, f'‚ö†Ô∏è**Downloading Failed**‚ö†Ô∏è\n**Name** =>> `{str(count).zfill(3)} {name1}`\n**Url** =>> {url}\n\n<blockquote expandable><i><b>Failed Reason: {str(e)}</b></i></blockquote>', disable_web_page_preview=True)
                count += 1
                failed_count += 1
                continue

    except Exception as e:
        await m.reply_text(e)
        time.sleep(2)

    success_count = len(links) - failed_count
    video_count = v2_count + mpd_count + m3u8_count + yt_count + drm_count + zip_count + other_count
    if raw_text7 == "/d":
        await bot.send_message(channel_id, f"<blockquote><b>üîÖSuccessfully Doneüíû</b></blockquote>\n<blockquote><b>üî∞Course : {b_name}</b></blockquote>\n<blockquote>üîó Total Links: {len(links)} \n üî∏ Total Video : {video_count}\n  üî∏ Total PDF : {pdf_count}\n</blockquote>\n")
    else:
        await bot.send_message(channel_id, f"<blockquote><b>üîÖSuccessfully Doneüíû</b></blockquote>\n<blockquote><b>üî∞Course : {b_name}</b></blockquote>\n<blockquote>üîó Total Links: {len(links)} \n üî∏ Total Video : {video_count}\n  üî∏ Total PDF : {pdf_count}\n</blockquote>\n")
        await bot.send_message(m.chat.id, f"<blockquote><b>‚úÖ Your Task is completed, please check your Set Channelüì±</b></blockquote>")

# =============== HELP =================
@bot.on_message(filters.command(["help"]))
async def help_cmd(client, m: Message):
    caption = (
        "üí• ùêÅùêéùêì ùêÇùêéùêåùêåùêÄùêçùêÉùêí\n"
        "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞\n"
        "üìå ùó†ùóÆùó∂ùóª ùóôùó≤ùóÆùòÅùòÇùóøùó≤ùòÄ:\n\n"
        "‚û• /start ‚Äì Bot Status Check\n"
        "‚û• /mars ‚Äì Extract from .txt (Auto)\n"
        "‚û• /y2t ‚Äì YouTube ‚Üí .txt Converter\n"
        "‚û• /ytm ‚Äì YouTube ‚Üí .mp3 downloader\n"
        "‚û• /t2t ‚Äì Text ‚Üí .txt Generator\n"
        "‚û• /stop ‚Äì Cancel Running Task\n"
    )
    await m.reply_text(caption, reply_markup=keyboard)

# =============== CALLBACK MENUS =================
@bot.on_callback_query()
async def cb_handler(client: Client, query: CallbackQuery):
    data = query.data
    if data == "features":
        caption = (
            "üíé ùêåùêÄùêàùêç ùêÖùêÑùêÄùêìùêîùêëùêÑùêí\n"
            "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞\n"
            "‚û• Upload videos via .txt file (/mars)\n"
            "‚û• Convert YouTube links to .txt (/y2t)\n"
            "‚û• Download YouTube as mp3 (/ytm)\n"
            "‚û• Generate .txt from plain text (/t2t)\n"
        )
        await query.message.edit_caption(caption, reply_markup=keyboard)

    elif data == "commands":
        caption = (
            "üí• ùêÅùêéùêì ùêÇùêéùêåùêåùêÄùêçùêÉùêí\n"
            "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞\n"
            "‚û• /start ‚Äì Bot Status\n"
            "‚û• /mars ‚Äì Upload from .txt\n"
            "‚û• /y2t ‚Äì YouTube ‚Üí .txt\n"
            "‚û• /ytm ‚Äì YouTube ‚Üí mp3\n"
            "‚û• /t2t ‚Äì Text ‚Üí .txt\n"
            "‚û• /stop ‚Äì Cancel Task\n"
        )
        await query.message.edit_caption(caption, reply_markup=keyboard)

    elif data == "plans":
        caption = (
            "üöÄ ùêèùêãùêÄùêçùêí\n"
            "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞\n"
            "‚ú® Free to use ‚Äî no limits!\n"
        )
        await query.message.edit_caption(caption, reply_markup=keyboard)

# =============== BROADCAST (Owner only) =================
@bot.on_message(filters.command("broadcast") & filters.private)
async def broadcast_handler(client: Client, message: Message):
    if message.chat.id != OWNER:
        return
    if not message.reply_to_message:
        await message.reply_text("Reply to a message with /broadcast to send it to all users.")
        return
    success, fail = 0, 0
    for user_id in list(set(TOTAL_USERS)):
        try:
            await client.copy_message(user_id, message.chat.id, message.reply_to_message.id)
            success += 1
        except (FloodWait, PeerIdInvalid, UserIsBlocked, InputUserDeactivated):
            fail += 1
            continue
        except:
            fail += 1
            continue
    await message.reply_text(f"‚úÖ Broadcast complete\nSuccess: {success} | Failed: {fail}")

@bot.on_message(filters.command("broadusers") & filters.private)
async def broadusers_handler(client: Client, message: Message):
    if message.chat.id != OWNER:
        return
    if not TOTAL_USERS:
        await message.reply_text("No users yet.")
        return
    total = len(TOTAL_USERS)
    await message.reply_text(f"üìä Total Users: {total}")

# =============== OTHER COMMANDS =================
@bot.on_message(filters.command(["y2t"]))
async def youtube_to_txt(client, message: Message):
    pass  # your logic here

@bot.on_message(filters.command(["ytm"]))
async def ytmusic(client, message: Message):
    pass  # your logic here

@bot.on_message(filters.command(["t2t"]))
async def text_to_txt(client, message: Message):
    pass  # your logic here

@bot.on_message(filters.command(["logs"]))
async def send_logs(client: Client, m: Message):
    try:
        with open("logs.txt", "rb") as file:
            await m.reply_document(document=file, caption="üìú Bot Logs")
    except Exception as e:
        await m.reply_text(f"**Error sending logs:**\n{e}")

@bot.on_message(filters.command(["id"]))
async def id_command(client, message: Message):
    chat_id = message.chat.id
    await message.reply_text(f"üîπ Chat ID: `{chat_id}`")

@bot.on_message(filters.command(["info"]))
async def info(bot: Client, update: Message):
    text = (
        f"‚ú® **Your Telegram Info** ‚ú®\n\n"
        f"üîπ Name: {update.from_user.first_name}\n"
        f"üîπ Username: @{update.from_user.username}\n"
        f"üîπ TG ID: `{update.from_user.id}`\n"
        f"üîπ Profile: {update.from_user.mention}\n"
    )
    await update.reply_text(text)

@bot.on_message(filters.command(["cookies"]))
async def cookies_handler(client: Client, m: Message):
    await m.reply_text("üìÇ Please upload your YouTube cookies `.txt` file.")

@bot.on_message(filters.command(["getcookies"]))
async def getcookies_handler(client: Client, m: Message):
    try:
        await client.send_document(chat_id=m.chat.id, document=cookies_file_path, caption="Here is your cookies file")
    except Exception as e:
        await m.reply_text(f"‚ö†Ô∏è {e}")

@bot.on_message(filters.command(["mfile"]))
async def mfile_handler(client: Client, m: Message):
    try:
        await client.send_document(chat_id=m.chat.id, document="main.py", caption="Here is the `main.py` file.")
    except Exception as e:
        await m.reply_text(f"‚ö†Ô∏è {e}")

# =============== RUN =================
print("‚úÖ Bot is running...")
bot.run()
